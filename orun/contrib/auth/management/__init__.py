"""
Creates permissions for all installed apps that need permissions.
"""
import getpass
import unicodedata

from orun.apps import apps as global_apps
# from orun.contrib.auth import get_permission_codename
from orun.contrib.contenttypes.management import create_contenttypes
from orun.core import exceptions
from orun.db import DEFAULT_DB_ALIAS, router


def _get_all_permissions(opts):
    """
    Return (codename, name) for all permissions in the given opts.
    """
    return {**opts.default_permissions, **opts.permissions}


# def _get_builtin_permissions(opts):
#     """
#     Return (codename, name) for all autogenerated permissions.
#     By default, this is ('add', 'change', 'delete', 'view')
#     """
#     perms = []
#     for action, text in opts.default_permissions.items():
#         perms.append((action, text))
#     return perms


def create_permissions(app_models, verbosity=2, interactive=True, using=DEFAULT_DB_ALIAS, apps=global_apps, **kwargs):
    try:
        ContentType = apps.get_model('content.type')
        Permission = apps.get_model('auth.permission')
    except LookupError:
        return
    ctypes = set()

    for model in app_models:
        app_config = model._meta.addon

        if not router.allow_migrate_model(using, Permission):
            return

        # This will hold the permissions we're looking for as
        # (content_type, (codename, name))
        searched_perms = []
        # The codenames and ctypes that should exist.
        ctype = ContentType.objects.db_manager(using).get_for_model(model, for_concrete_model=False)

        ctypes.add(ctype)
        for perm in _get_all_permissions(model._meta).items():
            searched_perms.append((ctype, perm))

        # Find all the Permissions that have a content_type for a model we're
        # looking for.  We don't need to check for codenames since we already have
        # a list of the ones we're going to create.
        all_perms = set(Permission.objects.using(using).filter(
            content_type__in=ctypes,
        ).values_list(
            "content_type", "codename"
        ))

        print('Create perm', model._meta.name)
        perms = [
            Permission(codename=codename, name=name, content_type=ct)
            for ct, (codename, name) in searched_perms
            if (ct.pk, codename) not in all_perms
        ]
        Permission.objects.using(using).bulk_create(perms)
        if verbosity >= 2:
            for perm in perms:
                print("Adding permission '%s'" % perm)


    def get_system_username():
        """
        Return the current system user's username, or an empty string if the
        username could not be determined.
        """
        try:
            result = getpass.getuser()
        except (ImportError, KeyError):
            # KeyError will be raised by os.getpwuid() (called by getuser())
            # if there is no corresponding entry in the /etc/passwd file
            # (a very restricted chroot environment, for example).
            return ''


def get_default_username(check_db=True):
    """
    Try to determine the current system user's username to use as a default.

    :param check_db: If ``True``, requires that the username does not match an
        existing ``auth.User`` (otherwise returns an empty string).
    :returns: The username, or an empty string if no username can be
        determined.
    """
    # If the User model has been swapped out, we can't make any assumptions
    # about the default user name.
    UserModel = global_apps['auth.user']

    default_username = get_system_username()
    try:
        default_username = (
            unicodedata.normalize('NFKD', default_username)
            .encode('ascii', 'ignore').decode('ascii')
            .replace(' ', '').lower()
        )
    except UnicodeDecodeError:
        return ''

    # Run the username validator
    try:
        UserModel._meta.get_field('username').run_validators(default_username)
    except exceptions.ValidationError:
        return ''

    # Don't return the default username if it is already taken.
    if check_db and default_username:
        try:
            UserModel._default_manager.get(username=default_username)
        except UserModel.DoesNotExist:
            pass
        else:
            return ''
    return default_username
